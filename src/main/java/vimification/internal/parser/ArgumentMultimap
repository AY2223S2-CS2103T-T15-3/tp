package vimification.internal.parser;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.HashSet;

/**
 * Stores mapping of flags to their respective arguments. Each flag may be associated with multiple
 * argument values. Values for a given flag are stored in a set, and the insertion ordering may be
 * maintained.
 */
public class ArgumentMultimap {

    private final Set<LiteralArgumentFlag> allowedFlags;

    /**
     * Flags mapped to their respective arguments.
     **/
    private final Map<LiteralArgumentFlag, Set<String>> args;

    public ArgumentMultimap(LiteralArgumentFlag... allowedFlags) {
        this.allowedFlags = Set.of(allowedFlags);
        this.args = new HashMap<>();
    }

    private void throwIfNotAllowed(LiteralArgumentFlag flag) {
        if (!allowedFlags.contains(flag)) {
            throw new ParserException("Invalid flag for this command");
        }
    }


    /**
     * Associates the specified argument value with {@code prefix} key in this map. If the map
     * previously contained a mapping for the key, the new value is appended to the list of existing
     * values.
     *
     * @param prefix Prefix key with which the specified argument value is to be associated
     * @param argValue Argument value to be associated with the specified prefix key
     */
    public void put(LiteralArgumentFlag flag, String value) {
        throwIfNotAllowed(flag);
        Set<String> argValues = args.computeIfAbsent(flag, k -> new HashSet<>());
        if (!argValues.add(value)) {
            throw new ParserException("Duplicated argument");
        }
    }

    public Set<String> get(LiteralArgumentFlag flag) {
        throwIfNotAllowed(flag);
        Set<String> result = args.get(flag);
        return result == null ? Set.of() : result;
    }

    public Set<String> remove(LiteralArgumentFlag flag) {
        throwIfNotAllowed(flag);
        Set<String> result = args.remove(flag);
        return result == null ? Set.of() : result;
    }

    public Optional<String> getFirst(LiteralArgumentFlag flag) {
        throwIfNotAllowed(flag);
        return args.getOrDefault(flag, Set.of())
                .stream()
                .findFirst();
    }
}
